)]}'
{"version":3,"sources":["urigo:angular/lib/angular-hash-key-copier.js","urigo:angular/lib/diff-array.js","urigo:angular/modules/angular-meteor-subscribe.js","urigo:angular/modules/angular-meteor-collections.js","urigo:angular/modules/angular-meteor-meteorCollection.js","urigo:angular/modules/angular-meteor-object.js","urigo:angular/modules/angular-meteor-template.js","urigo:angular/modules/angular-meteor-user.js","urigo:angular/modules/angular-meteor-methods.js","urigo:angular/modules/angular-meteor-session.js","urigo:angular/modules/angular-meteor-reactive-scope.js","urigo:angular/modules/angular-meteor-utils.js","urigo:angular/modules/angular-meteor-camera.js","urigo:angular/angular-meteor.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,iB;AACA,c;;AAEA,kF;AACA,kF;AACA,iC;AACA,+C;;AAEA,kF;AACA,mD;AACA,gD;;AAEA,yB;AACA,mE;;AAEA,Q;AACA,oB;AACA,Q;;;AAGA,oE;AACA,wC;;AAEA,6E;AACA,gF;AACA,wB;;AAEA,+E;AACA,+E;AACA,iF;AACA,iD;AACA,I;AACA,6D;AACA,8B;;AAEA,gC;;AAEA,G;;AAEA,qF;AACA,+E;AACA,6E;AACA,uC;;;AAGA,Q;AACA,qB;AACA,Q;;;AAGA,mF;AACA,4B;;AAEA,gF;AACA,uC;AACA,mE;AACA,I;AACA,0B;;AAEA,I;;AAEA,sD;AACA,qB;;AAEA,wC;AACA,iC;AACA,oC;;AAEA,yB;;AAEA,G;;;AAGA,Q;AACA,sB;AACA,Q;;;AAGA,0D;AACA,6C;;AAEA,qC;;AAEA,kD;;AAEA,6C;;AAEA,kD;;AAEA,I;;AAEA,G;;;AAGA,kD;AACA,qD;;AAEA,iE;;AAEA,iC;;AAEA,qC;;AAEA,6D;;AAEA,6C;;AAEA,6D;;AAEA,K;;AAEA,I;;AAEA,G;;;AAGA,mD;AACA,sD;;AAEA,2D;;AAEA,sB;;AAEA,sD;;AAEA,uD;;AAEA,iE;;AAEA,K;AACA,I;AACA,I;;AAEA,8B;;AAEA,yE;;AAEA,oC;;AAEA,sC;;AAEA,oE;;AAEA,8C;;AAEA,oE;;AAEA,M;;AAEA,K;;AAEA,I;;AAEA,G;;;AAGA,8D;AACA,0C;;AAEA,gC;;AAEA,+C;;AAEA,wC;;AAEA,+C;;AAEA,I;;AAEA,G;;;AAGA,oD;AACA,uD;;AAEA,iE;;AAEA,iC;;AAEA,qC;;AAEA,+D;;AAEA,6C;;AAEA,+D;;AAEA,K;;AAEA,I;;AAEA,G;;;AAGA,qD;AACA,wD;;AAEA,wD;;AAEA,4D;;AAEA,uB;;AAEA,iF;AACA,K;AACA,K;;AAEA,I;;AAEA,8B;;AAEA,yE;;AAEA,oC;;AAEA,sC;;AAEA,sE;;AAEA,8C;;AAEA,uE;;AAEA,M;;AAEA,K;;AAEA,I;;AAEA,G;;;AAGA,sF;AACA,+C;AACA,mD;;AAEA,4E;;AAEA,4C;;AAEA,gD;;AAEA,0B;;AAEA,K;;AAEA,I;;AAEA,kB;;AAEA,G;;;AAGA,2D;AACA,oC;;AAEA,uD;AACA,oB;;AAEA,mB;;AAEA,I;;AAEA,iD;AACA,gC;;AAEA,kC;;AAEA,I;;AAEA,6D;AACA,iC;;AAEA,oB;;AAEA,I;AACA,G;AACA,gF;AACA,qC;AACA,kB;;AAEA,G;;;AAGA,gF;AACA,uE;AACA,0C;;AAEA,qD;;AAEA,G;;;AAGA,Q;AACA,uB;AACA,Q;;;AAGA,U;AACA,6B;AACA,K;;AAEA,E;;AAEA,8E;AACA,oC;AACA,kF;;AAEA,2E;;AAEA,wB;;AAEA,wB;;AAEA,G;;AAEA,c;;;;;;;;;;;;;;;;;;AC5TA,a;;AAEA,6C;;AAEA,+C;AACA,uC;;AAEA,wD;AACA,+D;AACA,oD;AACA,iF;AACA,0E;AACA,wB;AACA,wB;AACA,iD;AACA,2B;AACA,kB;AACA,sC;AACA,iD;;AAEA,sC;AACA,sC;AACA,qC;AACA,K;AACA,0C;AACA,sC;AACA,qC;AACA,qC;AACA,K;;AAEA,4D;AACA,kE;AACA,gE;AACA,sB;AACA,sC;AACA,6C;AACA,sE;;AAEA,yC;AACA,4B;AACA,uB;AACA,S;;AAEA,kB;AACA,yC;;AAEA,wB;AACA,W;AACA,0C;AACA,iB;AACA,gB;AACA,M;AACA,wC;AACA,iD;AACA,0E;;AAEA,yC;AACA,mD;AACA,uB;AACA,wD;AACA,uB;AACA,S;;AAEA,yC;;AAEA,wB;AACA,W;AACA,0C;AACA,qB;AACA,iB;AACA,gB;AACA,M;AACA,4B;AACA,iD;;AAEA,yC;AACA,gC;AACA,uB;AACA,S;;AAEA,qC;AACA,kB;;AAEA,0B;AACA,W;AACA,8C;AACA,sB;AACA,K;AACA,K;;AAEA,2C;AACA,+B;;AAEA,kC;AACA,kC;AACA,mD;AACA,2E;AACA,kB;AACA,gF;;AAEA,kB;AACA,kC;;AAEA,oB;AACA,oC;;AAEA,+B;AACA,kE;AACA,K;AACA,K;AACA,E;;AAEA,mE;AACA,wE;AACA,kD;AACA,qB;;AAEA,iD;AACA,qD;AACA,2D;AACA,Y;AACA,kE;AACA,qC;AACA,K;AACA,K;;AAEA,mB;AACA,E;;AAEA,yD;AACA,uC;AACA,sF;AACA,E;;AAEA,0E;AACA,uD;AACA,wE;AACA,kB;;AAEA,+B;AACA,iC;;AAEA,U;;AAEA,oD;;AAEA,yD;AACA,e;;AAEA,6B;AACA,e;;AAEA,kC;;AAEA,+B;AACA,8B;AACA,S;AACA,sC;AACA,4D;AACA,uC;AACA,S;;AAEA,c;AACA,4B;AACA,O;;AAEA,wE;AACA,yE;AACA,2D;AACA,4E;AACA,uC;AACA,6B;AACA,O;AACA,O;AACA,G;;AAEA,kC;AACA,4C;AACA,kE;;AAEA,iC;AACA,qB;;AAEA,+B;AACA,E;;AAEA,iE;AACA,yD;AACA,yE;AACA,oC;AACA,oC;;AAEA,kB;;AAEA,+C;;AAEA,qC;AACA,wC;AACA,0C;AACA,6B;AACA,2B;AACA,K;;AAEA,kD;AACA,sC;AACA,a;AACA,K;;AAEA,2B;AACA,kE;AACA,+B;AACA,kE;AACA,qC;AACA,O;AACA,K;AACA,K;;AAEA,kC;AACA,qB;;AAEA,+B;AACA,E;;AAEA,wD;AACA,gD;AACA,gC;AACA,+B;;AAEA,gD;AACA,iD;AACA,qC;AACA,O;AACA,8C;AACA,K;;AAEA,uC;AACA,K;AACA,E;;AAEA,0E;AACA,uD;AACA,yD;AACA,oD;;AAEA,wE;AACA,yB;AACA,K;AACA,E;;AAEA,0D;AACA,uD;;AAEA,mE;AACA,wB;AACA,K;AACA,E;;AAEA,qC;AACA,uD;AACA,yD;;;;;;;;;;;;;;;;;;;ACnQA,a;AACA,4E;;AAEA,yD;AACA,iB;AACA,oB;;AAEA,uD;AACA,8B;;AAEA,iB;AACA,6B;AACA,yC;AACA,U;AACA,gC;AACA,+B;AACA,S;AACA,S;;AAEA,0D;;AAEA,0B;AACA,M;;AAEA,gC;AACA,gC;AACA,uD;AACA,8B;;AAEA,4C;;AAEA,8B;AACA,M;AACA,M;;AAEA,mE;AACA,8C;AACA,qE;AACA,gC;AACA,uD;;AAEA,2E;;AAEA,uC;AACA,4B;AACA,S;;AAEA,8B;AACA,M;AACA,I;;;;;;;;;;;;;;;;;;;ACjDA,a;AACA,2H;;AAEA,4E;AACA,wD;;AAEA,qD;AACA,yB;AACA,iC;;AAEA,c;AACA,E;;AAEA,sF;;AAEA,8D;AACA,kB;AACA,mC;AACA,iB;AACA,4C;;AAEA,I;AACA,6E;AACA,iE;AACA,uB;AACA,K;AACA,mC;AACA,8B;;AAEA,8B;AACA,0B;AACA,gC;AACA,gC;AACA,K;;AAEA,qE;AACA,oE;AACA,sF;AACA,6F;AACA,kE;AACA,oB;AACA,iC;AACA,gB;AACA,+D;AACA,S;AACA,S;AACA,iE;AACA,wD;AACA,oB;AACA,iC;AACA,gB;AACA,8D;AACA,S;AACA,S;AACA,K;;AAEA,4B;AACA,G;;AAEA,I;AACA,0E;AACA,K;AACA,wD;AACA,uE;AACA,4C;AACA,yC;AACA,mB;AACA,8C;AACA,4C;AACA,K;AACA,2E;AACA,0C;AACA,uC;AACA,iB;AACA,G;;AAEA,yE;AACA,E;;AAEA,kE;AACA,kB;AACA,mC;AACA,iB;AACA,4C;;AAEA,I;AACA,0E;AACA,gC;AACA,uB;AACA,K;AACA,kC;AACA,8B;;AAEA,kD;AACA,mB;AACA,sB;AACA,O;AACA,iF;AACA,oD;AACA,oB;AACA,iC;AACA,gB;AACA,+D;AACA,S;AACA,S;AACA,Y;AACA,4C;AACA,K;;AAEA,4B;AACA,G;;AAEA,I;AACA,4E;AACA,K;AACA,wD;AACA,oE;AACA,4C;AACA,yC;AACA,mB;AACA,2C;AACA,4C;AACA,K;AACA,2E;AACA,0C;AACA,2C;AACA,iB;AACA,G;;AAEA,yE;AACA,E;;AAEA,6D;AACA,8C;;AAEA,6C;AACA,+C;AACA,qD;AACA,kC;AACA,c;AACA,O;AACA,K;AACA,G;;AAEA,kB;AACA,E;;AAEA,2F;AACA,kD;AACA,qD;AACA,mC;AACA,uD;AACA,qG;AACA,O;AACA,c;;AAEA,8D;AACA,0C;AACA,2D;AACA,kF;AACA,+C;AACA,qE;AACA,e;AACA,a;;AAEA,sE;AACA,6D;AACA,0B;AACA,gC;AACA,0F;AACA,qB;AACA,W;;AAEA,oC;;AAEA,4D;AACA,mC;AACA,mC;AACA,6C;AACA,gB;AACA,sC;;AAEA,oE;AACA,6C;AACA,e;;AAEA,6D;AACA,2C;AACA,W;;AAEA,kC;AACA,U;;AAEA,kE;AACA,6D;AACA,6E;AACA,iF;AACA,W;;AAEA,qC;;AAEA,kC;AACA,6C;;AAEA,4B;AACA,2B;AACA,iD;AACA,4E;AACA,kB;AACA,8D;AACA,e;;AAEA,gG;;AAEA,oF;AACA,6F;AACA,6E;;AAEA,oF;AACA,iD;AACA,uE;AACA,iB;AACA,e;;AAEA,wE;AACA,mF;AACA,2E;AACA,8D;AACA,4D;AACA,oC;AACA,0C;AACA,sF;AACA,mC;AACA,qC;AACA,sC;AACA,8D;AACA,sC;AACA,0B;AACA,iE;AACA,qC;AACA,+C;AACA,mD;AACA,qB;AACA,0C;AACA,2F;AACA,qD;AACA,uB;AACA,qB;AACA,mB;AACA,mB;AACA,oD;AACA,uB;AACA,a;AACA,Y;AACA,mB;;AAEA,wB;AACA,+E;AACA,6B;AACA,uB;;AAEA,iD;AACA,6C;AACA,uB;;AAEA,kC;AACA,kC;;AAEA,uB;AACA,e;AACA,W;;AAEA,oC;;AAEA,4D;AACA,mC;AACA,mC;AACA,6C;AACA,gB;AACA,sC;;AAEA,oE;AACA,6C;AACA,e;;AAEA,6D;AACA,2C;AACA,W;;AAEA,kC;AACA,S;AACA,Q;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACtSA,a;;AAEA,iF;AACA,qE;;AAEA,+E;AACA,kI;AACA,8C;AACA,oH;AACA,oD;AACA,0G;AACA,qC;;AAEA,qD;AACA,wD;AACA,kB;AACA,M;;AAEA,0E;AACA,sB;AACA,uC;AACA,gD;;AAEA,Q;AACA,iF;AACA,qE;AACA,2B;AACA,S;AACA,uC;AACA,kC;;AAEA,2B;AACA,0D;;AAEA,yE;AACA,wE;AACA,0F;AACA,iG;AACA,4E;;AAEA,kE;AACA,wB;AACA,qC;AACA,oB;AACA,mE;AACA,a;AACA,gC;AACA,a;AACA,qE;AACA,4D;AACA,wB;AACA,qC;AACA,oB;AACA,kE;AACA,a;AACA,gC;AACA,a;AACA,S;AACA,gC;AACA,O;;AAEA,Q;AACA,8E;AACA,S;AACA,4D;AACA,2E;AACA,gD;AACA,6C;AACA,uB;AACA,kD;AACA,gD;AACA,S;AACA,+E;AACA,8C;AACA,2C;AACA,qB;AACA,O;;AAEA,6E;AACA,M;;AAEA,4D;AACA,sB;AACA,uC;AACA,gD;;AAEA,Q;AACA,8E;AACA,oC;AACA,2B;AACA,S;AACA,sC;AACA,kC;;AAEA,sD;AACA,wB;AACA,0B;AACA,W;AACA,qF;;AAEA,wD;AACA,wB;AACA,qC;AACA,oB;AACA,mE;AACA,a;AACA,gC;AACA,a;AACA,gB;AACA,gD;AACA,S;;AAEA,gC;AACA,O;;AAEA,Q;AACA,gF;AACA,S;AACA,4D;AACA,wE;AACA,gD;AACA,6C;AACA,uB;AACA,+C;AACA,gD;AACA,S;AACA,+E;AACA,8H;AACA,sD;AACA,8C;AACA,sD;AACA,+C;AACA,qB;AACA,O;;AAEA,6E;AACA,M;;AAEA,8D;AACA,sB;;AAEA,kB;AACA,uF;AACA,2B;AACA,4B;AACA,sB;AACA,mC;AACA,yB;AACA,S;AACA,wE;AACA,kD;AACA,yC;AACA,2C;AACA,uD;AACA,S;AACA,wC;AACA,2E;AACA,yE;AACA,4C;AACA,8B;AACA,qB;AACA,O;;AAEA,gE;AACA,+B;AACA,+B;AACA,kC;AACA,O;;AAEA,2C;AACA,+C;AACA,4C;AACA,0D;AACA,sB;AACA,U;AACA,8D;AACA,mD;AACA,oD;AACA,sD;AACA,sB;AACA,U;AACA,0D;AACA,oC;AACA,4C;AACA,kD;AACA,0D;AACA,sB;AACA,U;AACA,2C;AACA,4C;AACA,2B;AACA,iD;AACA,+B;AACA,uD;AACA,oD;AACA,iB;AACA,a;AACA,kB;AACA,4D;AACA,a;AACA,8C;AACA,W;;AAEA,2D;AACA,gC;AACA,sC;AACA,oD;AACA,wB;AACA,kB;AACA,iF;AACA,wD;AACA,uE;AACA,kC;AACA,sD;AACA,a;AACA,W;AACA,S;AACA,S;AACA,M;;AAEA,gD;AACA,mC;AACA,iC;AACA,kC;AACA,O;;AAEA,6B;AACA,kC;;AAEA,+B;AACA,mB;AACA,iC;AACA,O;AACA,M;;AAEA,sF;AACA,oB;AACA,8B;AACA,yC;AACA,gI;;AAEA,oD;;AAEA,kB;AACA,M;;AAEA,yC;AACA,M;;AAEA,oI;AACA,wE;AACA,8D;AACA,I;;AAEA,oD;AACA,oF;AACA,I;AACA,I;;;AAGA,4G;AACA,6D;AACA,qE;AACA,4B;AACA,0B;AACA,qF;AACA,O;AACA,0F;AACA,8H;AACA,O;AACA,4B;AACA,iD;;AAEA,iD;AACA,2C;AACA,+E;AACA,8C;AACA,oC;AACA,4D;AACA,S;AACA,O;;AAEA,gG;;AAEA,8B;AACA,oE;AACA,0C;AACA,2E;AACA,oD;AACA,4C;AACA,a;AACA,iF;AACA,4C;AACA,kD;AACA,qB;AACA,sD;AACA,kD;AACA,qB;;AAEA,wC;AACA,+C;AACA,gD;;AAEA,sE;;AAEA,4B;AACA,a;AACA,mB;AACA,S;AACA,O;;AAEA,S;AACA,0E;AACA,S;AACA,mC;AACA,gF;AACA,yB;AACA,0C;AACA,8B;AACA,W;AACA,kD;AACA,sB;AACA,S;;AAEA,0B;AACA,K;AACA,M;;AAEA,6E;AACA,qE;AACA,qB;AACA,4C;AACA,yC;AACA,uE;AACA,mC;AACA,mB;AACA,M;AACA,2C;AACA,+B;AACA,M;AACA,kE;;AAEA,kB;AACA,oC;;AAEA,oB;AACA,4C;AACA,M;AACA,sD;AACA,6B;AACA,K;AACA,K;AACA,C;;AAEA,iH;AACA,uF;AACA,oD;AACA,yB;AACA,yD;AACA,0D;AACA,gC;;AAEA,4C;AACA,2D;AACA,6E;AACA,4B;AACA,U;;AAEA,0C;AACA,4B;AACA,2B;AACA,gC;AACA,W;;AAEA,0B;AACA,O;AACA,M;;AAEA,4F;AACA,gG;AACA,M;;;;;;;;;;;;;;;;;;;AC5XA,wH;;AAEA,8G;AACA,+B;;AAEA,kD;AACA,oB;;AAEA,4D;AACA,I;;AAEA,+C;AACA,sD;AACA,gB;AACA,I;;AAEA,kD;AACA,oB;AACA,qC;;AAEA,8B;;AAEA,a;AACA,oB;AACA,2F;AACA,0B;AACA,0B;AACA,4B;AACA,wC;AACA,wB;AACA,qC;AACA,oB;AACA,6C;AACA,a;AACA,W;AACA,U;AACA,O;;AAEA,4B;AACA,I;;AAEA,gD;AACA,oB;AACA,qC;AACA,+B;AACA,qB;;AAEA,oB;AACA,wD;AACA,e;AACA,wB;AACA,wF;AACA,mC;AACA,iD;AACA,2C;AACA,W;AACA,S;AACA,c;AACA,0D;AACA,4B;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,8C;AACA,qC;AACA,mC;AACA,K;AACA,sC;;AAEA,kC;AACA,gC;AACA,K;AACA,mC;;AAEA,kE;AACA,qC;AACA,K;AACA,mC;AACA,I;;AAEA,+F;AACA,yC;AACA,mM;AACA,iC;AACA,I;;AAEA,oE;AACA,iE;AACA,sC;AACA,2C;AACA,0D;;AAEA,mC;AACA,6B;AACA,mB;;AAEA,8C;;AAEA,gB;AACA,I;;AAEA,mC;AACA,I;;;AAGA,kG;AACA,2D;AACA,oD;AACA,4B;AACA,wB;AACA,iF;AACA,O;AACA,oD;AACA,6H;AACA,O;;AAEA,sG;;AAEA,kE;;AAEA,6E;AACA,qB;AACA,S;;AAEA,kE;AACA,+D;AACA,oD;AACA,wC;AACA,+C;AACA,wC;AACA,0F;AACA,mE;AACA,a;AACA,W;AACA,iB;AACA,O;;AAEA,0E;AACA,gC;AACA,sB;AACA,S;AACA,yB;AACA,S;;AAEA,kB;AACA,M;AACA,M;;AAEA,iF;AACA,6D;AACA,kE;AACA,uD;AACA,mD;AACA,8B;;AAEA,sC;AACA,yD;AACA,2E;AACA,sB;AACA,Q;;AAEA,uC;AACA,sB;AACA,yB;AACA,8B;AACA,M;;AAEA,oB;AACA,G;AACA,M;;;;;;;;;;;;;;;;;;;AC3KA,0E;;AAEA,4C;AACA,6B;AACA,yD;AACA,U;AACA,iC;AACA,+B;AACA,iC;AACA,8B;AACA,iC;AACA,gC;AACA,0B;AACA,qF;;AAEA,sF;AACA,O;AACA,O;AACA,G;AACA,G;;AAEA,+C;AACA,e;AACA,Y;AACA,oB;AACA,mB;AACA,gD;AACA,uD;AACA,Q;AACA,mD;AACA,mC;AACA,oC;;AAEA,W;AACA,6C;AACA,+F;AACA,6H;AACA,6F;AACA,6G;AACA,Y;AACA,+D;AACA,0C;AACA,8C;AACA,4C;;AAEA,2E;;AAEA,oG;AACA,W;;AAEA,O;AACA,M;AACA,G;AACA,G;;AAEA,kD;AACA,a;AACA,uB;AACA,Y;AACA,qB;AACA,mB;AACA,mD;AACA,8D;AACA,qC;AACA,wC;AACA,8E;AACA,8C;AACA,4C;AACA,sC;AACA,a;AACA,gB;AACA,6F;AACA,S;AACA,O;AACA,M;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AC5EA,wF;;AAEA,wF;;AAEA,8C;AACA,sB;AACA,6C;AACA,gD;AACA,K;AACA,K;AACA,I;;AAEA,6E;AACA,yC;AACA,oB;;AAEA,kC;;AAEA,gC;;AAEA,kD;AACA,kC;AACA,4C;AACA,S;;AAEA,8B;AACA,M;;AAEA,kC;;AAEA,gC;;AAEA,kD;AACA,oC;AACA,qC;AACA,6C;AACA,c;AACA,8C;AACA,S;AACA,S;;AAEA,8B;AACA,M;;AAEA,mD;AACA,oD;AACA,wC;;AAEA,6B;AACA,sB;AACA,6C;AACA,oC;AACA,Y;AACA,0C;AACA,M;AACA,G;;AAEA,sD;;AAEA,gC;;AAEA,6D;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,wC;;AAEA,gC;;AAEA,iD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,6D;;AAEA,gC;;AAEA,sE;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,4C;;AAEA,gC;;AAEA,qD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,sD;;AAEA,gC;;AAEA,+D;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,uC;;AAEA,gC;;AAEA,gD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,6B;;AAEA,gC;;AAEA,kC;AACA,kB;AACA,iC;AACA,c;AACA,+B;AACA,W;;AAEA,8B;AACA,M;;AAEA,yC;;AAEA,gC;;AAEA,8C;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,+C;;AAEA,gC;;AAEA,sD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,8C;;AAEA,gC;;AAEA,qD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,6C;;AAEA,gC;;AAEA,oD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,6C;;AAEA,gC;;AAEA,oD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,6D;;AAEA,gC;;AAEA,oE;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,6C;;AAEA,gC;;AAEA,oD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;;AAEA,4C;;AAEA,gC;;AAEA,mD;AACA,gB;AACA,+B;AACA,Y;AACA,6B;AACA,S;;AAEA,8B;AACA,M;AACA,M;;;;;;;;;;;;;;;;;;;AC1QA,a;AACA,wE;;AAEA,qD;AACA,iB;AACA,2B;;AAEA,gC;;AAEA,iE;AACA,gB;AACA,+B;AACA,Y;AACA,iC;AACA,S;AACA,yC;;AAEA,8B;AACA,M;AACA,M;;;;;;;;;;;;;;;;;;ACnBA,a;AACA,8F;;AAEA,+D;AACA,2B;AACA,+B;;AAEA,c;;AAEA,sC;AACA,kD;AACA,gD;AACA,a;;AAEA,2D;AACA,+C;AACA,mB;;AAEA,S;AACA,Q;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACtBA,G;AACA,kC;AACA,G;AACA,qF;;AAEA,sF;AACA,wF;AACA,oB;AACA,oC;AACA,sC;;AAEA,gD;AACA,8B;AACA,K;;AAEA,wC;AACA,8D;;AAEA,8B;AACA,6B;AACA,mC;AACA,gC;AACA,iD;AACA,S;AACA,yB;AACA,K;;AAEA,0C;;AAEA,0B;AACA,I;AACA,kF;AACA,oB;AACA,oC;;;AAGA,gD;AACA,8B;AACA,K;;AAEA,wC;AACA,8D;;AAEA,kD;AACA,+C;AACA,S;AACA,K;;AAEA,0C;;AAEA,0B;AACA,I;AACA,I;;;;;;;;;;;;;;;;;;;ACpDA,a;AACA,oE;;AAEA,wD;AACA,uB;AACA,oB;AACA,gD;AACA,0C;AACA,M;AACA,wC;AACA,qC;AACA,8C;AACA,c;;AAEA,qD;AACA,oE;AACA,mD;AACA,S;AACA,6C;AACA,wC;AACA,oB;AACA,S;AACA,iE;AACA,kB;AACA,M;AACA,6G;AACA,oD;AACA,oC;AACA,+B;AACA,+B;AACA,8D;AACA,oB;AACA,O;AACA,+C;AACA,2C;AACA,0D;AACA,mD;AACA,S;AACA,S;AACA,iB;AACA,M;AACA,M;;AAEA,qD;AACA,sC;AACA,qE;AACA,4C;AACA,M;AACA,I;;;;;;;;;;;;;;;;;;;AChDA,a;AACA,qE;;AAEA,kD;AACA,iB;AACA,wC;AACA,mB;AACA,qB;;AAEA,gC;;AAEA,+D;AACA,kB;AACA,iC;;AAEA,iB;AACA,iC;AACA,S;;AAEA,8B;AACA,M;AACA,M;;;;;;;;;;;;;;;;;;;ACrBA,6C;AACA,sD;AACA,6B;AACA,+B;AACA,qC;AACA,0B;AACA,4B;AACA,wB;AACA,2B;AACA,2B;AACA,kC;AACA,yB;AACA,0B;AACA,iB;AACA,G;;AAEA,sG;AACA,8C;AACA,sC;AACA,4B;AACA,qD;AACA,uC;AACA,2B;AACA,4C;AACA,yD;AACA,6B;AACA,W;AACA,U;AACA,S;AACA,K;AACA,M;;AAEA,iE;AACA,sM;AACA,8J;AACA,wC;AACA,4C;AACA,gC;AACA,gD;AACA,oC;AACA,2D;AACA,+C;AACA,yD;AACA,+C;AACA,6C;AACA,qD;AACA,qD;AACA,mD;AACA,+C;AACA,uF;AACA,2D;AACA,uD;AACA,uD;AACA,uD;AACA,yD;AACA,qD;AACA,qC;AACA,6D;AACA,kC;AACA,wC;AACA,gE;AACA,+C;AACA,I","file":"/packages/urigo_angular.js","sourcesContent":["(function( ng ) {\n\t\"use strict\";\n\n\t// We're going to package this as its own module. Not sure how else to distribute\n\t// an AngularJS class since it depends on an actual application name at the code-\n\t// time of the class definition.\n\tvar module = ng.module( \"hashKeyCopier\", [] );\n\n\t// Define the injectable. We're using \"value\" because the result is a construtor,\n\t// NOT the result of a constructor instantiation. \n\tmodule.value( \"HashKeyCopier\", HashKeyCopier );\n\n\t// I am the constructor.\n\tfunction HashKeyCopier( source, destination, uniqueIdentifiers ) {\n\n\t\t// ---\n\t\t// INITIALIZATION.\n\t\t// ---\n\n\n\t\t// I am the key that AngularJS uses to store the expando property.\n\t\tvar hashKeyPropertyName = \"$$hashKey\";\n\n\t\t// I am the index of hashKeys in the source object. This provides a pseudo-\n\t\t// location of each hashKey value based on the structure of the source object.\n\t\tvar hashKeyIndex = {};\n\n\t\t// I am a collection of keys used to determine the identity of an object at a\n\t\t// given location within the source / destination targets. It is one of these\n\t\t// keys that will be used to determine if two objects are logically equivalent;\n\t\t// and therefore, should have the same hashKey.\n\t\t//\n\t\t// If nothing is provided, default to the most common - ID.\n\t\tif ( ! uniqueIdentifiers ) {\n\n\t\t\tuniqueIdentifiers = [ \"id\" ];\n\n\t\t}\n\n\t\t// I am the RegEx pattern that determins if a given string represents a proprietary\n\t\t// AngularJS name - they all being with \"$\". We don't need to waste our time \n\t\t// looking at these properties when it comes to iterating over our targets.\n\t\tvar angularJSPropertyPattern = /^$/i;\n\n\n\t\t// ---\n\t\t// PUBLIC METDHODS.\n\t\t// ---\n\n\n\t\t// I execute the copy operation from the source object to the destination object.\n\t\tfunction copyHashKeys() {\t\n\n\t\t\t// If either the existing or the source objects are empty, there's nothing to\n\t\t\t// do - just return the destination.\n\t\t\tif ( isTargetEmpty( source ) || isTargetEmpty( destination ) ) {\n\t\t\t\t\n\t\t\t\treturn( destination );\n\n\t\t\t}\n\n\t\t\t// Reset the hash key index for the copy operation.\n\t\t\thashKeyIndex = {};\n\n\t\t\t// Build and apply the hashkey index.\n\t\t\tbuildHashKeyIndexFromSource();\n\t\t\tapplyHashKeyIndexToDestination();\n\n\t\t\treturn( destination );\n\n\t\t}\n\n\n\t\t// ---\n\t\t// PRIVATE METDHODS.\n\t\t// ---\n\n\n\t\t// I apply the hashkey index to the current destination.\n\t\tfunction applyHashKeyIndexToDestination() {\n\n\t\t\tif ( ng.isArray( destination ) ) {\n\n\t\t\t\tapplyHashKeyIndexToArray( \"[]\", destination );\n\n\t\t\t} else if ( ng.isObject( destination ) ) {\n\n\t\t\t\tapplyHashKeyIndexToObject( \".\", destination );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// I apply the hashkey index to the given Array.\n\t\tfunction applyHashKeyIndexToArray( path, target ) {\n\n\t\t\tfor ( var i = 0, length = target.length ; i < length ; i++ ) {\n\n\t\t\t\tvar targetItem = target[ i ];\n\n\t\t\t\tif ( ng.isArray( targetItem ) ) {\n\n\t\t\t\t\tapplyHashKeyIndexToArray( ( path + \"[]\" ), targetItem );\n\n\t\t\t\t} else if ( ng.isObject( targetItem ) ) {\n\n\t\t\t\t\tapplyHashKeyIndexToObject( ( path + \".\" ), targetItem );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// I apply the hasheky index to the given Object.\n\t\tfunction applyHashKeyIndexToObject( path, target ) {\n\n\t\t\tvar identifier = getUniqueIdentifierForObject( target );\n\n\t\t\tif ( identifier ) {\n\n\t\t\t\tvar hashKeyPath = ( path + target[ identifier ] );\n\n\t\t\t\tif ( hashKeyIndex.hasOwnProperty( hashKeyPath ) ) {\n\n\t\t\t\t\ttarget[ hashKeyPropertyName ] = hashKeyIndex[ hashKeyPath ];\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\tfor ( var key in target ) {\n\n\t\t\t\tif ( target.hasOwnProperty( key ) && isUserDefinedProperty( key ) ) {\n\n\t\t\t\t\tvar targetItem = target[ key ];\n\n\t\t\t\t\tif ( ng.isArray( targetItem ) ) {\n\n\t\t\t\t\t\tapplyHashKeyIndexToArray( ( path + key + \"[]\" ), targetItem );\n\n\t\t\t\t\t} else if ( ng.isObject( targetItem ) ) {\n\n\t\t\t\t\t\tapplyHashKeyIndexToObject( ( path + key + \".\" ), targetItem );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// I build the hashkey index from the current source object.\n\t\tfunction buildHashKeyIndexFromSource() {\n\n\t\t\tif ( ng.isArray( source ) ) {\n\n\t\t\t\tbuildHashKeyIndexFromArray( \"[]\", source );\n\n\t\t\t} else if ( ng.isObject( source ) ) {\n\n\t\t\t\tbuildHashKeyIndexFromObject( \".\", source );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// I build the hashkey index from the given Array.\n\t\tfunction buildHashKeyIndexFromArray( path, target ) {\n\n\t\t\tfor ( var i = 0, length = target.length ; i < length ; i++ ) {\n\n\t\t\t\tvar targetItem = target[ i ];\n\n\t\t\t\tif ( ng.isArray( targetItem ) ) {\n\n\t\t\t\t\tbuildHashKeyIndexFromArray( ( path + \"[]\" ), targetItem );\n\n\t\t\t\t} else if ( ng.isObject( targetItem ) ) {\n\n\t\t\t\t\tbuildHashKeyIndexFromObject( ( path + \".\" ), targetItem );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// I build the hashkey index from the given Object.\n\t\tfunction buildHashKeyIndexFromObject( path, target ) {\n\n\t\t\tif ( target.hasOwnProperty( hashKeyPropertyName ) ) {\n\n\t\t\t\tvar identifier = getUniqueIdentifierForObject( target );\n\n\t\t\t\tif ( identifier ) {\n\n\t\t\t\t\thashKeyIndex[ path + target[ identifier ] ] = target[ hashKeyPropertyName ];\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var key in target ) {\n\n\t\t\t\tif ( target.hasOwnProperty( key ) && isUserDefinedProperty( key ) ) {\n\n\t\t\t\t\tvar targetItem = target[ key ];\n\n\t\t\t\t\tif ( ng.isArray( targetItem ) ) {\n\n\t\t\t\t\t\tbuildHashKeyIndexFromArray( ( path + key + \"[]\" ), targetItem );\n\n\t\t\t\t\t} else if ( ng.isObject( targetItem ) ) {\n\n\t\t\t\t\t\tbuildHashKeyIndexFromObject( ( path + key + \".\" ) , targetItem );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// I return the unique identifier for the given object; returns null if none of the \n\t\t// keys match any of the defined identifiers.\n\t\tfunction getUniqueIdentifierForObject( target ) {\n\n\t\t\tfor ( var i = 0, length = uniqueIdentifiers.length ; i < length ; i++ ) {\n\n\t\t\t\tvar identifier = uniqueIdentifiers[ i ];\n\n\t\t\t\tif ( target.hasOwnProperty( identifier ) ) {\n\n\t\t\t\t\treturn( identifier );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn( null );\n\n\t\t}\n\n\n\t\t// I check to see if the given object is locigally empty.\n\t\tfunction isTargetEmpty( target ) {\n\n\t\t\t// If the object is a falsey, determine it as empty.\n\t\t\tif ( ! target ) {\n\n\t\t\t\treturn( true );\n\n\t\t\t}\n\n\t\t\t// If the value is an array, check its length.\n\t\t\tif ( ng.isArray( target ) ) {\n\n\t\t\t\treturn( target.length === 0 );\n\n\t\t\t}\n\n\t\t\t// If the value is an object, consider to to be non-empty.\n\t\t\tif ( ng.isObject( target ) ) {\n\n\t\t\t\treturn( false );\n\n\t\t\t}\n\t\t\t\n\t\t\t// If the value was neither an array nor an object, consider it empty for the\n\t\t\t// purposes of our copy operation.\n\t\t\treturn( true );\n\n\t\t}\n\n\n\t\t// I determine if the given property name is one defined by the user (or more \n\t\t// specifically, one that is NOT defined by the AngularJS framework).\n\t\tfunction isUserDefinedProperty( name ) {\n\n\t\t\treturn( ! angularJSPropertyPattern.test( name ) );\n\n\t\t}\n\n\n\t\t// ---\n\t\t// RETURN PUBLIC API.\n\t\t// ---\n\n\n\t\treturn({\n\t\t\tcopyHashKeys: copyHashKeys\n\t\t});\n\n\t}\n\n\t// I provide a \"static\" method that encapsulates the proper instantation and \n\t// execution of the copy operation.\n\tHashKeyCopier.copyHashKeys = function( source, destination, uniqueIdentifiers ) {\n\n\t\tvar copier = new HashKeyCopier( source, destination, uniqueIdentifiers );\n\n\t\tcopier.copyHashKeys();\n\n\t\treturn( destination );\n\n\t};\n\n})( angular );","'use strict';\n\nvar module = angular.module('diffArray', []);\n\nvar idStringify = LocalCollection._idStringify;\nvar idParse = LocalCollection._idParse;\n\n// Calculates the differences between `lastSeqArray` and\n// `seqArray` and calls appropriate functions from `callbacks`.\n// Reuses Minimongo's diff algorithm implementation.\nvar diffArray = function (lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n  var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges;\n  var oldIdObjects = [];\n  var newIdObjects = [];\n  var posOld = {}; // maps from idStringify'd ids\n  var posNew = {}; // ditto\n  var posCur = {};\n  var lengthCur = lastSeqArray.length;\n  preventNestedDiff = preventNestedDiff || false;\n\n  _.each(seqArray, function (doc, i) {\n    newIdObjects.push({_id: doc._id});\n    posNew[idStringify(doc._id)] = i;\n  });\n  _.each(lastSeqArray, function (doc, i) {\n    oldIdObjects.push({_id: doc._id});\n    posOld[idStringify(doc._id)] = i;\n    posCur[idStringify(doc._id)] = i;\n  });\n\n  // Arrays can contain arbitrary objects. We don't diff the\n  // objects. Instead we always fire 'changedAt' callback on every\n  // object. The consumer of `observe-sequence` should deal with\n  // it appropriately.\n  diffFn(oldIdObjects, newIdObjects, {\n    addedBefore: function (id, doc, before) {\n      var position = before ? posCur[idStringify(before)] : lengthCur;\n\n      _.each(posCur, function (pos, id) {\n        if (pos >= position)\n          posCur[id]++;\n      });\n\n      lengthCur++;\n      posCur[idStringify(id)] = position;\n\n      callbacks.addedAt(\n        id,\n        seqArray[posNew[idStringify(id)]],\n        position,\n        before);\n    },\n    movedBefore: function (id, before) {\n      var prevPosition = posCur[idStringify(id)];\n      var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\n      _.each(posCur, function (pos, id) {\n        if (pos >= prevPosition && pos <= position)\n          posCur[id]--;\n        else if (pos <= prevPosition && pos >= position)\n          posCur[id]++;\n      });\n\n      posCur[idStringify(id)] = position;\n\n      callbacks.movedTo(\n        id,\n        seqArray[posNew[idStringify(id)]],\n        prevPosition,\n        position,\n        before);\n    },\n    removed: function (id) {\n      var prevPosition = posCur[idStringify(id)];\n\n      _.each(posCur, function (pos, id) {\n        if (pos >= prevPosition)\n          posCur[id]--;\n      });\n\n      delete posCur[idStringify(id)];\n      lengthCur--;\n\n      callbacks.removedAt(\n        id,\n        lastSeqArray[posOld[idStringify(id)]],\n        prevPosition);\n    }\n  });\n\n  _.each(posNew, function (pos, idString) {\n    var id = idParse(idString);\n\n    if (_.has(posOld, idString)) {\n      var newItem = seqArray[pos];\n      var oldItem = lastSeqArray[posOld[idString]];\n      var setDiff = diffObjectChanges(oldItem, newItem, preventNestedDiff);\n      if (newItem)\n        var unsetDiff = diffObjectRemovals(oldItem, newItem, preventNestedDiff);\n\n      if (setDiff)\n        setDiff._id = newItem._id;\n\n      if (unsetDiff)\n        unsetDiff._id = newItem._id;\n\n      if (setDiff || unsetDiff)\n        callbacks.changedAt(id, setDiff, unsetDiff, pos, oldItem);\n    }\n  });\n};\n\n// Takes an object and returns a shallow copy, ie. with all keys at\n// a one-level depth. Transforms the name of each key using dot notation\nvar flattenObject = function (object, parentKey) {\n  var flattened = {};\n\n  angular.forEach(object, function (value, key) {\n    if (isActualObject(value) && !_.isEmpty(value)) {\n      angular.extend(flattened, flattenObject(value, key));\n    } else {\n      var dotNotedKey = (parentKey) ? parentKey + \".\" + key : key;\n      flattened[dotNotedKey] = value;\n    }\n  });\n\n  return flattened;\n};\n\n// Can tell whether a value is an object and not an array\nvar isActualObject = function (value) {\n  return angular.isObject(value) && !angular.isArray(value) && !angular.isDate(value);\n};\n\n// Diffs two objects and returns the keys that have been added or changed.\n// Can be used to construct a Mongo {$set: {}} modifier\nvar diffObjectChanges = function (oldItem, newItem, preventNestedDiff) {\n  var result = {};\n\n  if (_.isUndefined(oldItem)) {\n    result = EJSON.clone(newItem)\n\n  } else {\n\n    angular.forEach(newItem, function (value, key) {\n\n      if (oldItem && angular.equals(value, oldItem[key]))\n        return;\n\n      if (key == '$$hashKey')\n        return;\n\n      if (isActualObject(value)) {\n\n        if (_.isEmpty(value)) {\n          result[key] = value;\n        }\n        else if (!preventNestedDiff) {\n          var diff = diffObjectChanges(oldItem[key], value);\n          if (diff) result[key] = diff;\n        }\n\n      } else {\n        result[key] = value;\n      }\n\n      // If a nested object is identical between newItem and oldItem, it\n      // is initially attached as an empty object. Here we remove it from\n      // the result if it was not empty from the beginning.\n      if (isActualObject(result[key]) && _.keys(result[key]).length === 0) {\n        if (_.keys(value).length !== 0)\n          delete result[key];\n      }\n    });\n  }\n\n  var resultKeys = _.keys(result);\n  var emptyResult = resultKeys.length === 0;\n  var hashKeyOnly = resultKeys.length === 1 && !!result.$$hashKey;\n\n  if (emptyResult || hashKeyOnly)\n    return undefined;\n\n  return flattenObject(result);\n};\n\n// Diffs two objects and returns the keys that have been removed.\n// Can be used to construct a Mongo {$unset: {}} modifier\nvar diffObjectRemovals = function (oldItem, newItem, preventNestedDiff) {\n  var oldItemKeys = _.keys(oldItem);\n  var newItemKeys = _.keys(newItem);\n\n  var result = {};\n\n  angular.forEach(oldItemKeys, function (key) {\n\n    // Check if property was removed.\n    if (!_.contains(newItemKeys, key) ||\n      angular.isUndefined(newItem[key])) {\n      if (key != '$$hashKey')\n        result[key] = true;\n    }\n\n    // A nulled field is not considered a removal.\n    else if (_.isNull(newItem[key])) {\n      return;\n    }\n\n    // Perform nested diff.\n    else if (isActualObject(oldItem[key]) && !preventNestedDiff) {\n      if (key != '$$hashKey') {\n        var diff = diffObjectRemovals(oldItem[key], newItem[key]);\n        if (diff) result[key] = diff;\n      }\n    }\n  });\n\n  if (_.keys(result).length === 0)\n    return undefined;\n\n  return flattenObject(result);\n};\n\nvar handleDeepProperties = function(object, paths, cb) {\n  angular.forEach(paths, function(value, path) {\n    var props = path.split('.');\n    var currentObject = object;\n\n    for (var i = 0; i < props.length - 1; i++) {\n      if(_.isUndefined(currentObject[props[i]])){\n        currentObject[props[i]] = {};\n      }\n      currentObject = currentObject[props[i]];\n    }\n\n    cb(currentObject, props[i], value);\n  });\n};\n\n// Diffs two objects and returns the keys that have been added or changed.\n// Can be used to construct a Mongo {$set: {}} modifier\nvar deepCopyObjectChanges = function (oldItem, newItem) {\n  var setDiff = diffObjectChanges(oldItem, newItem);\n\n  handleDeepProperties(oldItem, setDiff, function(object, prop, value) {\n    object[prop] = value;\n  });\n};\n\nvar deepCopyObjectRemovals = function (oldItem, newItem) {\n  var unsetDiff = diffObjectRemovals(oldItem, newItem);\n\n  handleDeepProperties(oldItem, unsetDiff, function(object, prop) {\n    delete object[prop];\n  });\n};\n\nmodule.value('diffArray', diffArray);\nmodule.value('deepCopyChanges', deepCopyObjectChanges);\nmodule.value('deepCopyRemovals', deepCopyObjectRemovals);\n","'use strict';\nvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', []);\n\nangularMeteorSubscribe.service('$meteorSubscribe', ['$q',\n  function ($q) {\n    var self = this;\n\n    this._subscribe = function(scope, deferred, args) {\n      var subscription = null;\n\n      args.push({\n        onReady: function() {\n          deferred.resolve(subscription);\n        },\n        onError: function(err) {\n          deferred.reject(err);\n        }\n      });\n\n      subscription =  Meteor.subscribe.apply(scope, args);\n\n      return subscription;\n    };\n\n    this.subscribe = function(){\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n      var subscription = null;\n\n      self._subscribe(this, deferred, args);\n\n      return deferred.promise;\n    };\n  }]);\n\nangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe',\n  function($rootScope, $q, $meteorSubscribe) {\n    Object.getPrototypeOf($rootScope).$meteorSubscribe = function() {\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n\n      var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\n      this.$on('$destroy', function() {\n        subscription.stop();\n      });\n\n      return deferred.promise;\n    };\n}]);\n","'use strict';\nvar angularMeteorCollections = angular.module('angular-meteor.collections', ['angular-meteor.subscribe', 'hashKeyCopier']);\n\nvar AngularMeteorCollection = function (collection, $q, selector, options) {\n  var self = collection.find(selector, options).fetch();\n\n  self.__proto__ = AngularMeteorCollection.prototype;\n  self.__proto__.$q = $q;\n  self.$$collection = collection;\n\n  return self;\n};\n\nAngularMeteorCollection.prototype = []; // Allows inheritance of native Array methods.\n\nAngularMeteorCollection.prototype.save = function save(docs) {\n  var self = this,\n    collection = self.$$collection,\n    $q = self.$q,\n    promises = []; // To store all promises.\n\n  /*\n   * The upsertObject function will either update an object if the _id exists\n   * or insert an object if the _id is not set in the collection.\n   * Returns a promise.\n   */\n  function upsertObject(item, $q) {\n    var deferred = $q.defer();\n\n    item = angular.copy(item);\n    delete item.$$hashKey;\n    for (var property in item) {\n      delete property.$$hashKey;\n    }\n\n    if (item._id) { // Performs an update if the _id property is set.\n      var item_id = item._id; // Store the _id in temporary variable\n      delete item._id; // Remove the _id property so that it can be $set using update.\n      var objectId = (item_id._str) ? new Meteor.Collection.ObjectID(item_id._str) : item_id;\n      collection.update(objectId, {$set: item}, function (error) {\n        if (error) {\n          deferred.reject(error);\n        } else {\n          deferred.resolve({_id: objectId, action: \"updated\"});\n        }\n      });\n    } else { // Performs an insert if the _id property isn't set.\n      collection.insert(item, function (error, result) {\n        if (error) {\n          deferred.reject(error);\n        } else {\n          deferred.resolve({_id: result, action: \"inserted\"});\n        }\n      });\n    }\n\n    return deferred.promise;\n  }\n\n  /*\n   * How to update the collection depending on the 'docs' argument passed.\n   */\n  if (docs) { // Checks if a 'docs' argument was passed.\n    if (angular.isArray(docs)) { // If an array of objects were passed.\n      angular.forEach(docs, function (doc) {\n        this.push(upsertObject(doc, $q));\n      }, promises);\n    } else { // If a single object was passed.\n      promises.push(upsertObject(docs, $q));\n    }\n  } else { // If no 'docs' argument was passed, save the entire collection.\n    angular.forEach(self, function (doc) {\n      this.push(upsertObject(doc, $q));\n    }, promises);\n  }\n\n  return $q.all(promises); // Returns all promises when they're resolved.\n};\n\nAngularMeteorCollection.prototype.remove = function remove(keys) {\n  var self = this,\n    collection = self.$$collection,\n    $q = self.$q,\n    promises = []; // To store all promises.\n\n  /*\n   * The removeObject function will delete an object with the _id property\n   * equal to the specified key.\n   * Returns a promise.\n   */\n  function removeObject(key, $q) {\n    var deferred = $q.defer();\n\n    if (key) { // Checks if 'key' argument is set.\n      if(key._id) {\n        key = key._id;\n      }\n      var objectId = (key._str) ? new Meteor.Collection.ObjectID(key._str) : key;\n      collection.remove(objectId, function (error) {\n        if (error) {\n          deferred.reject(error);\n        } else {\n          deferred.resolve({_id: objectId, action: \"removed\"});\n        }\n      });\n    } else {\n      deferred.reject(\"key cannot be null\");\n    }\n\n    return deferred.promise;\n  }\n\n  /*\n   * What to remove from collection depending on the 'keys' argument passed.\n   */\n  if (keys) { // Checks if a 'keys' argument was passed.\n    if (angular.isArray(keys)) { // If an array of keys were passed.\n      angular.forEach(keys, function (key) {\n        this.push(removeObject(key, $q));\n      }, promises);\n    } else { // If a single key was passed.\n      promises.push(removeObject(keys, $q));\n    }\n  } else { // If no 'keys' argument was passed, save the entire collection.\n    angular.forEach(self, function (doc) {\n      this.push(removeObject(doc._id, $q));\n    }, promises);\n  }\n\n  return $q.all(promises); // Returns all promises when they're resolved.\n};\n\nvar updateAngularCollection = function (newArray, oldArray) {\n  if (!newArray || !oldArray) return newArray;\n\n  for (var i = 0; i < newArray.length; i++) {\n    for (var j = 0; j < oldArray.length; j++) {\n      if (angular.equals(newArray[i], oldArray[j])) {\n        newArray[i] = oldArray[j];\n        break;\n      }\n    }\n  }\n\n  return newArray;\n};\n\nangularMeteorCollections.factory('$collection', ['$q', 'HashKeyCopier', '$meteorSubscribe',\n  function ($q, HashKeyCopier, $meteorSubscribe) {\n    return function (collection, selector, options) {\n      if (!selector) selector = {};\n      if (!(collection instanceof Meteor.Collection)) {\n        throw new TypeError(\"The first argument of $collection must be a Meteor.Collection object.\");\n      }\n      return {\n\n        bindOne: function(scope, model, id, auto, publisher) {\n          Tracker.autorun(function(self) {\n            scope[model] = collection.findOne(id, options);\n            if (!scope.$root.$$phase) scope.$apply(); // Update bindings in scope.\n            scope.$on('$destroy', function () {\n              self.stop(); // Stop computation if scope is destroyed.\n            });\n          });\n\n          if (auto) { // Deep watches the model and performs autobind.\n            scope.$watch(model, function (newItem, oldItem) {\n              if (newItem)\n                if (newItem._id)\n                  collection.update({_id: newItem._id}, { $set: _.omit(newItem, '_id') });\n            }, true);\n          }\n\n          var deferred = $q.defer();\n\n          if (publisher) {  // Subscribe to a publish method\n            var publishName = null;\n            if (publisher === true)\n              publishName = collection._name;\n            else\n              publishName = publisher;\n\n            $meteorSubscribe.subscribe(publishName).then(function(){\n              deferred.resolve(scope[model]);\n            });\n\n          } else { // If no subscription, resolve immediately\n            deferred.resolve(scope[model]);\n          }\n\n          return deferred.promise;\n        },\n\n        bind: function (scope, model, auto, publisher, paginate) {\n          auto = auto || false; // Sets default binding type.\n          if (!(typeof auto === 'boolean')) { // Checks if auto is a boolean.\n            throw new TypeError(\"The third argument of bind must be a boolean.\");\n          }\n\n          var unregisterWatch = null;\n\n          var rebind = function(){\n            Tracker.autorun(function (self) {\n\n              if (paginate){\n                options = {\n                  limit: parseInt(scope.perPage),\n                  skip: (parseInt(scope.page) - 1) * parseInt(scope.perPage)\n                };\n                if (scope.sort) { options.sort = scope.sort; }\n              }\n\n              var ngCollection = new AngularMeteorCollection(collection, $q, selector, options);\n\n              // Bind collection to model in scope. Transfer $$hashKey based on _id.\n              var newArray = HashKeyCopier.copyHashKeys(scope[model], ngCollection, [\"_id\"]);\n              scope[model] = updateAngularCollection(newArray, scope[model]);\n\n              if (!scope.$root.$$phase) scope.$apply(); // Update bindings in scope.\n              scope.$on('$destroy', function () {\n                self.stop(); // Stop computation if scope is destroyed.\n              });\n            });\n\n            if (auto) { // Deep watches the model and performs autobind.\n              unregisterWatch = scope.$watch(model, function (newItems, oldItems) {\n                // Remove items that don't exist in the collection anymore.\n                angular.forEach(oldItems, function (oldItem) {\n                  var index = newItems.map(function (item) {\n                    return item._id;\n                  }).indexOf(oldItem._id);\n                  if (index == -1) { // To here get all objects that pushed or spliced\n                    var localIndex;\n                    if (!oldItem._id)\n                      localIndex = -1;\n                    else if (oldItem._id && !oldItem._id._str)\n                      localIndex = -1;\n                    else {\n                      localIndex = newItems.map(function (item) {\n                        if (item._id)\n                          return item._id._str;\n                      }).indexOf(oldItem._id._str);\n                    }\n                    if (localIndex == -1){\n                      if (oldItem._id) { // This is a check to get only the spliced objects\n                        newItems.remove(oldItem._id);\n                      }\n                    }\n                  }\n                });\n                newItems.save(); // Saves all items.\n              }, auto);\n            }\n          };\n          rebind();\n\n          if (paginate){\n            scope.$watchGroup(['page', 'sort'], function(newValues, oldValues){\n              if (!newValues)\n                return;\n\n              if (newValues[0] == oldValues[0] &&\n                newValues[1] == oldValues[1])\n                return;\n\n              if (unregisterWatch)\n                unregisterWatch();\n\n              rebind();\n            });\n          }\n\n          var deferred = $q.defer();\n\n          if (publisher) {  // Subscribe to a publish method\n            var publishName = null;\n            if (publisher === true)\n              publishName = collection._name;\n            else\n              publishName = publisher;\n\n            $meteorSubscribe.subscribe(publishName).then(function(){\n              deferred.resolve(scope[model]);\n            });\n\n          } else { // If no subscription, resolve immediately\n            deferred.resolve(scope[model]);\n          }\n\n          return deferred.promise;\n        }\n      };\n    }\n  }\n]);\n","'use strict';\n\nvar angularMeteorCollections = angular.module('angular-meteor.meteor-collection',\n  ['angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray']);\n\n// The reason angular meteor collection is a factory function and not something\n// that inherit from array comes from here: http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n// We went with the direct extensions approach\nangularMeteorCollections.factory('AngularMeteorCollection', ['$q', '$meteorSubscribe', '$meteorUtils', '$rootScope',\n  '$timeout', 'deepCopyChanges', 'deepCopyRemovals',\n  function ($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, deepCopyChanges, deepCopyRemovals) {\n    var AngularMeteorCollection = {};\n\n    AngularMeteorCollection.subscribe = function () {\n      $meteorSubscribe.subscribe.apply(this, arguments);\n      return this;\n    };\n\n    AngularMeteorCollection.save = function save(docs, useUnsetModifier) {\n      var self = this,\n        collection = self.$$collection,\n        promises = []; // To store all promises.\n\n      /*\n       * The upsertObject function will either update an object if the _id exists\n       * or insert an object if the _id is not set in the collection.\n       * Returns a promise.\n       */\n      function upsertObject(item, $q) {\n        var deferred = $q.defer();\n\n        // delete $$hashkey\n        item = $meteorUtils.stripDollarPrefixedKeys(item);\n\n        if (item._id) { // Performs an update if the _id property is set.\n          var item_id = item._id; // Store the _id in temporary variable\n          delete item._id; // Remove the _id property so that it can be $set using update.\n          var objectId = (item_id._str) ? new Meteor.Collection.ObjectID(item_id._str) : item_id;\n          var modifier = (useUnsetModifier) ? {$unset: item} : {$set: item};\n\n          collection.update(objectId, modifier, function (error) {\n            if (error) {\n              deferred.reject(error);\n            } else {\n              deferred.resolve({_id: objectId, action: \"updated\"});\n            }\n            $rootScope.$apply();\n          });\n        } else { // Performs an insert if the _id property isn't set.\n          collection.insert(item, function (error, result) {\n            if (error) {\n              deferred.reject(error);\n            } else {\n              deferred.resolve({_id: result, action: \"inserted\"});\n            }\n            $rootScope.$apply();\n          });\n        }\n        return deferred.promise;\n      }\n\n      /*\n       * How to update the collection depending on the 'docs' argument passed.\n       */\n      if (docs) { // Checks if a 'docs' argument was passed.\n        if (angular.isArray(docs)) { // If an array of objects were passed.\n          angular.forEach(docs, function (doc) {\n            this.push(upsertObject(doc, $q));\n          }, promises);\n        } else { // If a single object was passed.\n          promises.push(upsertObject(docs, $q));\n        }\n      } else { // If no 'docs' argument was passed, save the entire collection.\n        angular.forEach(self, function (doc) {\n          this.push(upsertObject(doc, $q));\n        }, promises);\n      }\n\n      return $q.all(promises); // Returns all promises when they're resolved.\n    };\n\n    AngularMeteorCollection.remove = function remove(keys) {\n      var self = this,\n        collection = self.$$collection,\n        promises = []; // To store all promises.\n\n      /*\n       * The removeObject function will delete an object with the _id property\n       * equal to the specified key.\n       * Returns a promise.\n       */\n      function removeObject(key, $q) {\n        var deferred = $q.defer();\n\n        if (key) { // Checks if 'key' argument is set.\n          if (key._id) {\n            key = key._id;\n          }\n          var objectId = (key._str) ? new Meteor.Collection.ObjectID(key._str) : key;\n\n          collection.remove(objectId, function (error) {\n            if (error) {\n              deferred.reject(error);\n            } else {\n              deferred.resolve({_id: objectId, action: \"removed\"});\n            }\n            $rootScope.$apply();\n          });\n        } else {\n          deferred.reject(\"key cannot be null\");\n        }\n\n        return deferred.promise;\n      }\n\n      /*\n       * What to remove from collection depending on the 'keys' argument passed.\n       */\n      if (keys) { // Checks if a 'keys' argument was passed.\n        if (angular.isArray(keys)) { // If an array of keys were passed.\n          angular.forEach(keys, function (key) {\n            this.push(removeObject(key, $q));\n          }, promises);\n        } else { // If a single key was passed.\n          promises.push(removeObject(keys, $q));\n        }\n      } else { // If no 'keys' argument was passed, save the entire collection.\n        // When removing all, we do not use collection.remove({}) because Meteor doesn't give the client side that permissions\n        // http://stackoverflow.com/a/15465286/1426570\n        var originalSelf = angular.copy(self);\n        angular.forEach(originalSelf, function (doc) {\n          this.push(removeObject(doc._id, $q));\n        }, promises);\n      }\n\n      return $q.all(promises); // Returns all promises when they're resolved.\n    };\n\n    AngularMeteorCollection.updateCursor = function (cursor) {\n      var self = this;\n\n      var promise;\n      // Function applies async to combine multiple operations (savings, deletions etc)\n      // in one processing.\n      function safeApply() {\n        if (promise) {\n          $timeout.cancel(promise);\n          promise = null;\n        }\n        // Clearing the watch is needed so no updates are sent to server\n        // while handling updates from the server.\n        if (!self.UPDATING_FROM_SERVER) {\n          self.UPDATING_FROM_SERVER = true;\n          if (!$rootScope.$$phase) $rootScope.$apply();\n        }\n        promise = $timeout(function () {\n          // Saves changes happened within the previous update from server.\n          updateCollection(self, self._serverBackup, self.diffArrayFunc);\n          self.UPDATING_FROM_SERVER = false;\n          $rootScope.$apply();\n        }, 0, false);\n      }\n\n      // XXX - consider adding an option for a non-orderd result\n      // for faster performance\n      if (self.observeHandle) {\n        self.observeHandle.stop();\n      }\n\n      self.observeHandle = cursor.observe({\n        addedAt: function (document, atIndex) {\n          self.splice(atIndex, 0, document);\n          self._serverBackup.splice(atIndex, 0, document);\n          safeApply();\n        },\n        changedAt: function (document, oldDocument, atIndex) {\n          deepCopyChanges(self[atIndex], document);\n          deepCopyRemovals(self[atIndex], document);\n          self._serverBackup[atIndex] = self[atIndex];\n          safeApply();\n        },\n        movedTo: function (document, fromIndex, toIndex) {\n          self.splice(fromIndex, 1);\n          self.splice(toIndex, 0, document);\n          self._serverBackup.splice(fromIndex, 1);\n          self._serverBackup.splice(toIndex, 0, document);\n          safeApply();\n        },\n        removedAt: function (oldDocument) {\n          function findRemoveInd(col, doc) {\n            var removedObj;\n            // No _.findIndex in underscore 1.5.x\n            if (doc._id._str) {\n              removedObj = _.find(col, function (obj) {\n                return obj._id._str == doc._id._str;\n              });\n            }\n            else {\n              removedObj = _.findWhere(col, {_id: doc._id});\n            }\n            return _.indexOf(col, removedObj);\n          }\n\n          var removeInd = findRemoveInd(self, oldDocument);\n          if (removeInd != -1) {\n            self.splice(removeInd, 1);\n            self._serverBackup.splice(removeInd, 1);\n            safeApply();\n          } else {\n            // If it's been removed on client then it's already not in collection\n            // itself but still is in the _serverBackup.\n            removeInd = findRemoveInd(self._serverBackup, oldDocument);\n            if (removeInd != -1) {\n              self._serverBackup.splice(removeInd, 1);\n            }\n          }\n        }\n      });\n    };\n\n    AngularMeteorCollection.stop = function () {\n      if (this.unregisterAutoBind){\n        this._isAutoBind = false;\n        this.unregisterAutoBind();\n      }\n\n      if (this.observeHandle)\n        this.observeHandle.stop();\n\n      while (this.length > 0) {\n        this.pop();\n        this._serverBackup.pop();\n      }\n    };\n\n    var createAngularMeteorCollection = function (cursor, collection, diffArrayFunc) {\n      var data = [];\n      data._serverBackup = [];\n      data.diffArrayFunc = diffArrayFunc;\n      data.$$collection = angular.isDefined(collection) ? collection : $meteorUtils.getCollectionByName(cursor.collection.name);\n\n      angular.extend(data, AngularMeteorCollection);\n\n      return data;\n    };\n\n    return createAngularMeteorCollection;\n  }]);\n\nangularMeteorCollections.factory('$meteorCollectionFS', ['$meteorCollection', 'diffArray', function ($meteorCollection, diffArray) {\n  var noNestedDiffArray = function (lastSeqArray, seqArray, callbacks) {\n    return diffArray(lastSeqArray, seqArray, callbacks, true);\n  };\n\n  return function (reactiveFunc, auto, collection) {\n    return new $meteorCollection(reactiveFunc, auto, collection, noNestedDiffArray);\n  };\n}]);\n\n\nangularMeteorCollections.factory('$meteorCollection', ['AngularMeteorCollection', '$rootScope', 'diffArray',\n  function (AngularMeteorCollection, $rootScope, diffArray) {\n    return function (reactiveFunc, auto, collection, diffArrayFunc) {\n      // Validate parameters\n      if (!reactiveFunc) {\n        throw new TypeError(\"The first argument of $meteorCollection is undefined.\");\n      }\n      if (!(typeof reactiveFunc == \"function\" || angular.isFunction(reactiveFunc.find))) {\n        throw new TypeError(\"The first argument of $meteorCollection must be a function or a have a find function property.\");\n      }\n      auto = auto !== false;\n      diffArrayFunc = diffArrayFunc || diffArray;\n\n      if (!(typeof reactiveFunc == \"function\")) {\n        var cursorFunc = reactiveFunc.find;\n        collection = angular.isDefined(collection) ? collection : reactiveFunc;\n        var originalCollection = reactiveFunc;\n        reactiveFunc = function () {\n          return cursorFunc.apply(originalCollection, [{}]);\n        }\n      }\n\n      var ngCollection = new AngularMeteorCollection(reactiveFunc(), collection, diffArrayFunc);\n\n      function setAutoBind() {\n        if (auto) { // Deep watches the model and performs autobind.\n          ngCollection._isAutoBind = true;\n          ngCollection.unregisterAutoBind = $rootScope.$watch(function () {\n            if (ngCollection.UPDATING_FROM_SERVER) {\n              return 'UPDATING_FROM_SERVER';\n            }\n            return angular.copy(_.without(ngCollection, 'UPDATING_FROM_SERVER'));\n          }, function (newItems, oldItems) {\n            if (ngCollection._isAutoBind == false)\n              return;\n            if (newItems === 'UPDATING_FROM_SERVER' ||\n              oldItems === 'UPDATING_FROM_SERVER')\n              return;\n\n            if (newItems !== oldItems) {\n              ngCollection._isAutoBind = false;\n              ngCollection.unregisterAutoBind();\n\n              updateCollection(ngCollection, oldItems, diffArrayFunc);\n\n              setAutoBind();\n            }\n          }, true);\n        }\n      }\n\n      /**\n       * Fetches the latest data from Meteor and update the data variable.\n       */\n      Tracker.autorun(function () {\n        // When the reactive func gets recomputated we need to stop any previous\n        // observeChanges\n        Tracker.onInvalidate(function () {\n          ngCollection.stop();\n        });\n        ngCollection.updateCursor(reactiveFunc());\n        setAutoBind();\n      });\n\n      return ngCollection;\n    }\n  }]);\n\n// Finds changes between two collections and saves difference into first one.\nfunction updateCollection(newCollection, oldCollection, diffMethod) {\n  var addedCount = 0;\n  diffMethod(oldCollection, newCollection, {\n    addedAt: function (id, item, index) {\n      var newValue = newCollection.splice(index - addedCount, 1).pop();\n      newCollection.save(newValue);\n      addedCount++;\n    },\n    removedAt: function (id, item, index) {\n      newCollection.remove(id);\n    },\n    changedAt: function (id, setDiff, unsetDiff, index, oldItem) {\n\n      if (setDiff)\n        newCollection.save(setDiff);\n\n      if (unsetDiff)\n        newCollection.save(unsetDiff, true);\n    },\n    movedTo: function (id, item, fromIndex, toIndex) {\n      // XXX do we need this?\n    }\n  });\n}\n\nangularMeteorCollections.run(['$rootScope', '$q', '$meteorCollection', '$meteorCollectionFS', '$meteorSubscribe',\n  function ($rootScope, $q, $meteorCollection, $meteorCollectionFS, $meteorSubscribe) {\n    var collectionFunc = function (collectionType) {\n      return function() {\n        var args = Array.prototype.slice.call(arguments);\n        var collection = collectionType.apply(this, args);\n        var subscription = null;\n\n        collection.subscribe = function () {\n          var args = Array.prototype.slice.call(arguments);\n          subscription = $meteorSubscribe._subscribe(this, $q.defer(), args);\n          return collection;\n        };\n\n        this.$on('$destroy', function () {\n          collection.stop();\n          if (subscription)\n            subscription.stop();\n        });\n\n        return collection;\n      }\n    };\n\n    Object.getPrototypeOf($rootScope).$meteorCollection = collectionFunc($meteorCollection);\n    Object.getPrototypeOf($rootScope).$meteorCollectionFS = collectionFunc($meteorCollectionFS);\n  }]);\n","var angularMeteorObject = angular.module('angular-meteor.object', ['angular-meteor.utils', 'angular-meteor.subscribe']);\n\nangularMeteorObject.factory('AngularMeteorObject', ['$q', '$meteorSubscribe', function($q, $meteorSubscribe) {\n  var AngularMeteorObject = {};\n\n  AngularMeteorObject.getRawObject = function () {\n    var self = this;\n\n    return angular.copy(_.omit(self, self.$$internalProps));\n  };\n\n  AngularMeteorObject.subscribe = function () {\n    $meteorSubscribe.subscribe.apply(this, arguments);\n    return this;\n  };\n\n  AngularMeteorObject.save = function save(docs) {\n    var self = this,\n      collection = self.$$collection;\n\n    var deferred = $q.defer();\n\n    if (self)\n      if (self._id){\n        var updates = docs? docs : angular.copy(_.omit(self, '_id', self.$$internalProps));\n        collection.update(\n          {_id: self._id},\n          { $set: updates },\n          function(error, numberOfDocs){\n            if (error) {\n              deferred.reject(error);\n            } else {\n              deferred.resolve(numberOfDocs);\n            }\n          }\n        );\n      }\n\n    return deferred.promise;\n  };\n\n  AngularMeteorObject.reset = function reset() {\n    var self = this,\n      collection = self.$$collection,\n      options = self.$$options,\n      id = self.$$id;\n\n    if (collection){\n      var serverValue = collection.findOne(id, options);\n      var prop;\n      if (serverValue) {\n        angular.extend(Object.getPrototypeOf(self), Object.getPrototypeOf(serverValue));\n        for (prop in serverValue) {\n          if (serverValue.hasOwnProperty(prop)) {\n            self[prop] = serverValue[prop];\n          }\n        }\n      } else {\n        for (prop in _.omit(self, self.$$internalProps)) {\n          delete self[prop];\n        }\n      }\n    }\n  };\n\n  AngularMeteorObject.stop = function stop() {\n    if (this.unregisterAutoDestroy) {\n      this.unregisterAutoDestroy();\n    }\n    this.unregisterAutoDestroy = null;\n\n    if (this.unregisterAutoBind) {\n      this.unregisterAutoBind();\n    }\n    this.unregisterAutoBind = null;\n\n    if (this.autorunComputation && this.autorunComputation.stop) {\n      this.autorunComputation.stop();\n    }\n    this.autorunComputation = null;\n  };\n\n// A list of internals properties to not watch for, nor pass to the Document on update and etc.\n  AngularMeteorObject.$$internalProps = [\n    'save', 'reset', '$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject',\n    'collection', '_eventEmitter'\n  ];\n\n  var createAngularMeteorObject = function(collection, id, options){\n    // Make data not be an object so we can extend it to preserve\n    // Collection Helpers and the like\n    var data = new function SubObject() {};\n    angular.extend(data, collection.findOne(id, options));\n\n    data.$$collection = collection;\n    data.$$options = options;\n    data.$$id = id;\n\n    angular.extend(data, AngularMeteorObject);\n\n    return data;\n  };\n\n  return createAngularMeteorObject;\n}]);\n\n\nangularMeteorObject.factory('$meteorObject', ['$rootScope', '$meteorUtils', 'AngularMeteorObject',\n  function($rootScope, $meteorUtils, AngularMeteorObject) {\n    return function(collection, id, auto, options) {\n      // Validate parameters\n      if (!collection) {\n        throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n      }\n      if (!angular.isFunction(collection.findOne)) {\n        throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n      }\n\n      auto = auto !== false; // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n\n      var data = new AngularMeteorObject(collection, id, options);\n\n      data.autorunComputation = $meteorUtils.autorun($rootScope, function() {\n        data.reset();\n      });\n\n      if (auto) { // Deep watches the model and performs autobind.\n        data.unregisterAutoBind = $rootScope.$watch(function(){\n          return _.omit(data, data.$$internalProps);\n        }, function (newItem, oldItem) {\n          if (newItem !== oldItem && newItem) {\n            var newItemId = newItem._id;\n            if (newItemId && !_.isEmpty(newItem = _.omit(angular.copy(newItem), '_id'))) {\n              collection.update({_id: newItemId}, {$set: newItem});\n            }\n          }\n        }, true);\n      }\n\n      data.unregisterAutoDestroy = $rootScope.$on('$destroy', function() {\n        if (data && data.stop) {\n          data.stop();\n        }\n        data = undefined;\n      });\n\n      return data;\n    };\n  }]);\n\nangularMeteorObject.run(['$rootScope', '$q', '$meteorObject', '$meteorSubscribe',\n  function($rootScope, $q, $meteorObject, $meteorSubscribe) {\n    Object.getPrototypeOf($rootScope).$meteorObject = function() {\n      var args = Array.prototype.slice.call(arguments);\n      var object = $meteorObject.apply(this, args);\n      var subscription = null;\n\n      object.subscribe = function () {\n        var args = Array.prototype.slice.call(arguments);\n        subscription = $meteorSubscribe._subscribe(this, $q.defer(), args);\n        return object;\n      };\n\n      this.$on('$destroy', function() {\n        object.stop();\n        if (subscription)\n          subscription.stop();\n\t  });\n\n      return object;\n\t};\n  }]);\n","var angularMeteorTemplate = angular.module('angular-meteor.template', []);\n\nangularMeteorTemplate.run(['$templateCache',\n  function ($templateCache) {\n    angular.forEach(Template, function (template, name) {\n      if (\n        name.charAt(0) != \"_\"  &&\n        name != \"prototype\"  &&\n        name != \"loginButtons\" &&\n        name != \"instance\"  &&\n        name != \"currentData\"  &&\n        name != \"parentData\"  &&\n        name != \"body\"  &&\n        name != \"registerHelper\") { // Ignores templates with names starting with \"_\"\n\n          $templateCache.put(name, '<ng-template name=\"' + name + '\"></ng-template>');\n      }\n    });\n  }\n]);\n\nangularMeteorTemplate.directive('ngTemplate', [\n  function () {\n    return {\n      restrict: 'E',\n      scope: false,\n      template: function (element, attributes) {\n        return Blaze.toHTML(Template[attributes.name]);\n      },\n      link: function (scope, element, attributes) {\n        var name = attributes.name,\n          template = Template[name];\n\n        /**\n         * Includes the templates event maps.\n         * Attaching events using selectors is not the recommended approach taken by AngularJS.\n         * That being said, the template event maps are included to maintain flexibility in the Meteor + Angular integration.\n         * It is not angular-meteor's role to dictate which approach a developer should take,\n         * so angular-meteor has left it up to the user to decide which approach they prefer when developing.\n         **/\n        angular.forEach(template._events, function (eventObj) {\n          var eventType = eventObj.events,\n            eventSelector = eventObj.selector,\n            eventHandler = eventObj.handler;\n\n          // Test all eventType to see if there is an equivalent in jQuery.\n\n          $('ng-template[name=\"' + name + '\"] ' + eventSelector + '').bind(eventType, eventHandler);\n        });\n\n      }\n    };\n  }\n]);\n\nangularMeteorTemplate.directive('meteorInclude', [\n  '$compile',\n  function ($compile) {\n    return {\n      restrict: 'AE',\n      scope: false,\n      link: function (scope, element, attributes) {\n        var name = attributes.meteorInclude || attributes.src;\n        if (name && Template[name]) {\n          var template = Template[name];\n          var viewHandler = Blaze.renderWithData(template, scope, element[0]);\n          $compile(element.contents())(scope);\n          scope.$on('$destroy', function() {\n            Blaze.remove(viewHandler);\n          });\n        } else {\n          console.error(\"meteorTemplate: There is no template with the name '\" + name + \"'\");\n        }\n      }\n    };\n  }\n]);","var angularMeteorUser = angular.module('angular-meteor.user', ['angular-meteor.utils']);\n\nangularMeteorUser.run(['$rootScope', '$meteorUtils', function($rootScope, $meteorUtils){\n\n  $meteorUtils.autorun($rootScope, function(){\n    if (Meteor.user) {\n      $rootScope.currentUser = Meteor.user();\n      $rootScope.loggingIn = Meteor.loggingIn();\n    }\n  });\n}]);\n\nangularMeteorUser.service('$meteorUser', ['$rootScope', '$meteorUtils', '$q',\n  function($rootScope, $meteorUtils, $q){\n    var self = this;\n\n    this.waitForUser = function(){\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() )\n          deferred.resolve( Meteor.user() );\n      });\n\n      return deferred.promise;\n    };\n\n    this.requireUser = function(){\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() ) {\n          if ( Meteor.user() == null)\n            deferred.reject(\"AUTH_REQUIRED\");\n          else\n            deferred.resolve( Meteor.user() );\n        }\n      });\n\n      return deferred.promise;\n    };\n\n    this.requireValidUser = function(validatorFn) {\n      return self.requireUser().then(function(user){\n        var valid = validatorFn( user );\n\n        if ( valid === true )\n          return user;\n        else if ( typeof valid === \"string\" )\n          return $q.reject( valid );\n        else\n          return $q.reject( \"FORBIDDEN\" );\n\t  });\n\t};\n\n    this.loginWithPassword = function(user, password){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithPassword(user, password, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.createUser = function(options){\n\n      var deferred = $q.defer();\n\n      Accounts.createUser(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.changePassword = function(oldPassword, newPassword){\n\n      var deferred = $q.defer();\n\n      Accounts.changePassword(oldPassword, newPassword, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.forgotPassword = function(options){\n\n      var deferred = $q.defer();\n\n      Accounts.forgotPassword(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.resetPassword = function(token, newPassword){\n\n      var deferred = $q.defer();\n\n      Accounts.resetPassword(token, newPassword, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.verifyEmail = function(token){\n\n      var deferred = $q.defer();\n\n      Accounts.verifyEmail(token, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.logout = function(){\n\n      var deferred = $q.defer();\n\n      Meteor.logout(function(err){\n          if (err)\n            deferred.reject(err);\n          else\n            deferred.resolve();\n        });\n\n      return deferred.promise;\n    };\n\n    this.logoutOtherClients = function(){\n\n      var deferred = $q.defer();\n\n      Meteor.logoutOtherClients(function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.loginWithFacebook = function(options){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithFacebook(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.loginWithTwitter = function(options){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithTwitter(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.loginWithGoogle = function(options){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithGoogle(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.loginWithGithub = function(options){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithGithub(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.loginWithMeteorDeveloperAccount = function(options){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithMeteorDeveloperAccount(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.loginWithMeetup = function(options){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithMeetup(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n\n    this.loginWithWeibo = function(options){\n\n      var deferred = $q.defer();\n\n      Meteor.loginWithWeibo(options, function(err){\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve();\n      });\n\n      return deferred.promise;\n    };\n  }]);\n","'use strict';\nvar angularMeteorMethods = angular.module('angular-meteor.methods', []);\n\nangularMeteorMethods.service('$meteorMethods', ['$q',\n  function ($q) {\n    this.call = function(){\n\n      var deferred = $q.defer();\n\n      Array.prototype.push.call(arguments, function (err, data) {\n        if (err)\n          deferred.reject(err);\n        else\n          deferred.resolve(data);\n      });\n      Meteor.call.apply(this, arguments);\n\n      return deferred.promise;\n    };\n  }]);","'use strict';\nvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils']);\n\nangularMeteorSession.factory('$meteorSession', ['$meteorUtils',\n  function ($meteorUtils) {\n    return function (session) {\n\n      return {\n\n        bind: function(scope, model) {\n          $meteorUtils.autorun(scope, function() {\n            scope[model] = Session.get(session);\n          });\n\n          scope.$watch(model, function (newItem, oldItem) {\n            Session.set(session, scope[model]);\n          }, true);\n\n        }\n      };\n    }\n  }\n]);\n\n","/**\n * Created by netanel on 29/12/14.\n */\nvar angularMeteorReactiveScope = angular.module('angular-meteor.reactive-scope', []);\n\nangularMeteorReactiveScope.run(['$rootScope', '$parse', function($rootScope, $parse) {\n  Object.getPrototypeOf($rootScope).getReactively = function(property, objectEquality) {\n    var self = this;\n    var getValue = $parse(property);\n    objectEquality = !!objectEquality;\n\n    if (!self.hasOwnProperty('$$trackerDeps')) {\n      self.$$trackerDeps = {};\n    }\n\n    if (!self.$$trackerDeps[property]) {\n      self.$$trackerDeps[property] = new Tracker.Dependency();\n\n      self.$watch(function() {\n        return getValue(self)\n      }, function(newVal, oldVal) {\n        if (newVal !== oldVal) {\n          self.$$trackerDeps[property].changed();\n        }\n      }, objectEquality);\n    }\n\n    self.$$trackerDeps[property].depend();\n\n    return getValue(self);\n  };\n  Object.getPrototypeOf($rootScope).getCollectionReactively = function(property) {\n    var self = this;\n    var getValue = $parse(property);\n\n\n    if (!self.hasOwnProperty('$$trackerDeps')) {\n      self.$$trackerDeps = {};\n    }\n\n    if (!self.$$trackerDeps[property]) {\n      self.$$trackerDeps[property] = new Tracker.Dependency();\n\n      self.$watchCollection(property, function() {\n        self.$$trackerDeps[property].changed();\n      });\n    }\n\n    self.$$trackerDeps[property].depend();\n\n    return getValue(self);\n  };\n}]);\n","'use strict';\nvar angularMeteorUtils = angular.module('angular-meteor.utils', []);\n\nangularMeteorUtils.service('$meteorUtils', [ '$timeout',\n  function ($timeout) {\n    var self = this;\n    this.getCollectionByName = function(string){\n      return Mongo.Collection.get(string);\n    };\n    this.autorun = function(scope, fn) {\n      // wrapping around Deps.autorun\n      var comp = Tracker.autorun(function(c) {\n        fn(c);\n\n        // this is run immediately for the first call\n        // but after that, we need to $apply to start Angular digest\n        if (!c.firstRun) $timeout(angular.noop, 0);\n      });\n      // stop autorun when scope is destroyed\n      scope.$on('$destroy', function() {\n        comp.stop();\n      });\n      // return autorun object so that it can be stopped manually\n      return comp;\n    };\n    // Borrowed from angularFire - https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n    this.stripDollarPrefixedKeys = function (data) {\n      if( !angular.isObject(data) ||\n        data instanceof Date ||\n        data instanceof File ||\n        (typeof FS === 'object' && data instanceof FS.File)) {\n        return data;\n      }\n      var out = angular.isArray(data)? [] : {};\n      angular.forEach(data, function(v,k) {\n        if(typeof k !== 'string' || k.charAt(0) !== '$') {\n          out[k] = self.stripDollarPrefixedKeys(v);\n        }\n      });\n      return out;\n    };\n  }]);\n\nangularMeteorUtils.run(['$rootScope', '$meteorUtils',\n  function($rootScope, $meteorUtils) {\n    Object.getPrototypeOf($rootScope).$meteorAutorun = function(fn) {\n      return $meteorUtils.autorun(this, fn);\n    };\n}]);\n","'use strict';\nvar angularMeteorUtils = angular.module('angular-meteor.camera', []);\n\nangularMeteorUtils.service('$meteorCamera', ['$q',\n  function ($q) {\n    this.getPicture = function(options){\n      if (!options)\n        options = {};\n\n      var deferred = $q.defer();\n\n      MeteorCamera.getPicture(options, function (error, data) {\n        if (error)\n          deferred.reject(error);\n\n        if (data)\n          deferred.resolve(data);\n      });\n\n      return deferred.promise;\n    };\n  }]);\n","// Define angular-meteor and its dependencies\nvar angularMeteor = angular.module('angular-meteor', [\n  'angular-meteor.subscribe',\n  'angular-meteor.collections',\n  'angular-meteor.meteor-collection',\n  'angular-meteor.object',\n  'angular-meteor.template',\n  'angular-meteor.user',\n  'angular-meteor.methods',\n  'angular-meteor.session',\n  'angular-meteor.reactive-scope',\n  'angular-meteor.utils',\n  'angular-meteor.camera',\n  'hashKeyCopier'\n]);\n\nangularMeteor.run(['$compile', '$document', '$rootScope', function ($compile, $document, $rootScope) {\n    // Recompile after iron:router builds page\n    if(typeof Router != 'undefined') {\n      var appLoaded = false;\n      Router.onAfterAction(function(req, res, next) {\n        Tracker.afterFlush(function() {\n          if (!appLoaded) {\n            $compile($document)($rootScope);\n            if (!$rootScope.$$phase) $rootScope.$apply();\n            appLoaded = true;\n          }\n        })\n      });\n    }\n  }]);\n\n// Putting all services under $meteor service for syntactic sugar\nangularMeteor.service('$meteor', ['$meteorCollection', '$meteorCollectionFS', '$meteorObject', '$meteorMethods', '$meteorSession', '$meteorSubscribe', '$meteorUtils', '$meteorCamera', '$meteorUser',\n  function($meteorCollection, $meteorCollectionFS, $meteorObject, $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils, $meteorCamera, $meteorUser){\n    this.collection = $meteorCollection;\n    this.collectionFS = $meteorCollectionFS;\n    this.object = $meteorObject;\n    this.subscribe = $meteorSubscribe.subscribe;\n    this.call = $meteorMethods.call;\n    this.loginWithPassword = $meteorUser.loginWithPassword;\n    this.requireUser = $meteorUser.requireUser;\n    this.requireValidUser = $meteorUser.requireValidUser;\n    this.waitForUser = $meteorUser.waitForUser;\n    this.createUser = $meteorUser.createUser;\n    this.changePassword = $meteorUser.changePassword;\n    this.forgotPassword = $meteorUser.forgotPassword;\n    this.resetPassword = $meteorUser.resetPassword;\n    this.verifyEmail = $meteorUser.verifyEmail;\n    this.loginWithMeteorDeveloperAccount = $meteorUser.loginWithMeteorDeveloperAccount;\n    this.loginWithFacebook = $meteorUser.loginWithFacebook;\n    this.loginWithGithub = $meteorUser.loginWithGithub;\n    this.loginWithGoogle = $meteorUser.loginWithGoogle;\n    this.loginWithMeetup = $meteorUser.loginWithMeetup;\n    this.loginWithTwitter = $meteorUser.loginWithTwitter;\n    this.loginWithWeibo = $meteorUser.loginWithWeibo;\n    this.logout = $meteorUser.logout;\n    this.logoutOtherClients = $meteorUser.logoutOtherClients;\n    this.session = $meteorSession;\n    this.autorun = $meteorUtils.autorun;\n    this.getCollectionByName = $meteorUtils.getCollectionByName;\n    this.getPicture = $meteorCamera.getPicture;\n}]);\n"]}